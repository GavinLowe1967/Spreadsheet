// The factorial function
def fact(n: Int) : Int = 
  if(n <= 1) 1 else n*fact(n-1)

def sum(xs: List[Int]): Int = 
  if(isEmpty(xs)) 0 else head(xs) + sum(tail(xs))

def apply[A,B](f: A => B, x: A): B = f(x)

def double(y: Float): Float = 2.0*y

// Row for the first empty cell in column c from row r.
def firstEmptyInCol(c: Column, r: Row): Row =
  Cell(c,r) match{ 
    case Empty => r; 
    case _: Int => firstEmptyInCol(c, r+1)
    case _ => firstEmptyInCol(c, r+1) 
  }

// =======================================================

// Inputs in column A

// Simple tests in row 0
#F0 = apply(double, 3.0) 
#B0 = sum([1,2,3,4])
#C0 = 1/0 // Evaluation error
#D0 = 3; #D0 = 4.0 // Evaluation error
val hello = "Hello"; #E0 = hello

// factorials, rows 1-4
for(r <- #1 to #4; c <- [#B, #C]; if r != #2){
  Cell(c, r) = fact(Cell(#A,r))
}

val firstEmpty = firstEmptyInCol(#A, #1) // Should give #4
Cell(#D, firstEmpty) = "first empty"

// More in row 6
#B6 = 3+#A1 // untyped cell read.
#C6 = if(false) 3 else #A1 // Untyped cell read.
// Test of scoping
val y = 3
def f(x: Int): Int = x+y
def g(z: Int): Int = { val y = 10; f(z) }
#D6 = g(1) // should be 4

// This test checks the inner declaration of flag doesn't leak. 
val flag = true
for(r <- #7 to #8; if r == #6 || flag){ 
  Cell(#B, r) = flag; val flag = false 
}  

// Test of empty blocks.
for(x <- #0 until #10){ }