// The factorial function
def fact(n: Int) : Int = 
  if(n <= 1) 1 else n*fact(n-1)

def sum(xs: List[Int]): Int = 
  if(isEmpty(xs)) 0 else head(xs) + sum(tail(xs))
def sum(xs: List[Float]): Float = 
  if(isEmpty(xs)) 0.0 else head(xs) + sum(tail(xs))

def apply[A,B](f: A => B, x: A): B = f(x)

def double(n: Int): Int = 2*n
def double(y: Float): Float = 2.0*y

// Row for the first empty cell in column c from row r.
def firstEmptyInCol(c: Column, r: Row): Row =
  Cell(c,r) match{ 
    case Empty => r; 
    case _: Int => firstEmptyInCol(c, r+1)
    case _ => firstEmptyInCol(c, r+1) 
  }

// =======================================================

// Inputs in column A

// Simple tests in row 0
val s = sum: List[Int] => Int
#A0 = sum([2.4,4.6])
#B0 = sum([1,4]): Int + s([2,3]) + sum([]: List[Int]) // + sum([]) *** Not allowed
#C0 = 1/0: Int // Evaluation error
#D0 = 3; #D0 = 4.0 // Evaluation error
val hello = "Hello"; #E0 = hello
#F0 = apply(double: Float => Float, 3.0) : Float 
// #F0 = double(3.0)
#G0 = double(2)

// factorials, rows 1-4
for(r <- #1 to #4; c <- [#B, #C]; if r != #2){
  Cell(c, r) = fact(Cell(#A,r))
}

val firstEmpty = firstEmptyInCol(#A, #1) // Should give #4
Cell(#D, firstEmpty) = "first empty"

// More in row 6
val ff = fact: Int => Int
#A6 = ff(3)
#B6 = 3+#A1 // untyped cell read.
#C6 = if(false) 3 else #A1 // Untyped cell read.
// Test of scoping
val y = 3
#D6 = g(1) // should be 4
def g(z: Int): Int = { val y = 10; f(z) }
def f(x: Int): Int = x+y
// Note: above tests that a forward reference to a function is allowed. 

// This test checks the inner declaration of flag doesn't leak. 
val flag = true
for(r <- #7 to #8; if r == #6 || flag){ 
  // Cell(#B, r) = flag; val flag = false // Illegal forward reference.
  Cell(#B, r) = true; val flag = false 
}  
// Repeated variable in for loop.  Allowed but yuk!
for(r <- 2 to 2; r <- #5+r to #6+r) Cell(#C, r) = 6 

// Test of empty blocks.
for(x <- #0 until #10){ }