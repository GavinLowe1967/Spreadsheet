https://retractionwatch.com/2013/04/18/influential-reinhart-rogoff-economics-paper-suffers-database-error/

Current
=======




Priorities
==========


* Overloading.

- Use the following rule: an overloaded function may not have a polymorphic
  instance.  And allow overloading only via defs -- not vals.  This avoids a
  lot of difficulties, and doesn't seem to lose much -- only distasteful
  overloadings.

- Require all uses of an overloaded function to either be an application of
  that function, (e.g. "double(3.4)") or explicitly typed (e.g. "map(double:
  Int => Int, List(3))").

- Extend environment to allow name to map to multiple values.  Note:
  declarations from outer scopes are removed.

- At point of declaration, check types are distinct: this is easy given the
  above rule.  (TypeCheker.typeCheckStmtList.)

- At point of typechecking a function application, identify the instance that
  applies.  This should be unique.  Record the type of the arguments for this
  unique instance in the FunctionApp object.  Consider cases like def
  f(x:Int,y:Int) = ...; def f(x:Float,y:Float) = ...; f(3,#A1).


* Allow typing on LHS of val declarations, e.g. "val x: Int = 3", "val x: Int
  = #A3".

* List comprehensions.

* Allow assertions, error.

* "println" statements.

* Add "if" directives.

* Haskell standard prelude.

* Improve syntax for function declarations and applications -- currying.

Low Priority
============

* Improve treatment of Strings:
- Allow non-quoted strings in CSV
- Think about escaped characters in non-quoted string cells.

* Order relations on rows, columns

* Look again at Unification.scala.  Are all branches tested?

* Catch stack overflows.

* In Environment, use null intead of Empty() (to save memory). 




===================================== DONE



1. Add double-write error, giving all places where written.

(a) Set CellSource when value entered, or CSV read in.  Stop
  Environment.getCell from adding source. -- done

(b) When writing to cell, add source; so there are potentially two types of
  sources, the cell the value was read from, and the script code that produced
  that value.  Set combinatiopn in Execution.perform, case Directive. -- done

(c) show in selection -- done

(d) Add double-write error -- done, needs improving

(e) Can a write overwrite user data?  -- error detected

(f) Can a user input overwrite written data? -- yes
** In these cases, keep the user data, store an error elsewhere. 

(g) Change MultipleWriteError to store list of Values.

(h) Change user feedback, e.g. "Value 5 from cell write at line 53: #D3 = 5",
"User data 5".
-- Mostly done.  Check results again.  Tidy up Execution.writeCell.  Consider 
   the case where the cell already holds a MultipleWriteError. -- done

(i)  Colour all errors red. -- done


1. Split cells into user cells and calculated cells.  Needs change in Model.cells.  

* Changes in Environment: userCells and calculatedCells initialised with Empty()

* Change cells in Model to getCell.

* In TopLevelTest, re-add tests for errors

* Use null to represent empty cells, and adapt getCell

*** For loops with repeated names. - test; add to TopLevelTest -- done

*** Explicit type for function. - test -- done 

*** Should typechecking of for statement start new scope for each generator?
    I don't think so, because it doesn't backtrack into the earlier scope.

2. Add more patterns for cell match expressions, e.g. "_" or "_: Int" as
   wildcard?  -- DONE
a) Syntax: done
b) Parsing: done
c) Typechecking: done
d) Evaluation: done

*** does parser work on, e.g. truely + 3?  It does now.

* Tidy up parsing files.  
  - Split expressions and declarations into separate file -- done
  - Split parsers for types into separate class. -- done

* Allow typed expressions, e.g. "[]: List[Int]".  ":" should bind more tightly
  than infix operators.  Have new syntactic term TypedExp(e: Exp, t: TypeT).
  - New syntactic term -- done
  - Parsing, excluding typed cell reads -- done
  - Type checking -- done
  - Execution. -- done

1. Tidy up this file!

- Seems to need newline at end 

- EqTypeConstraint.intersection -- test **

- Parser for strings in script.  

- Improve error messages concerning polymorphic types: "val xs = head(3)" ->
  Expected List[TypeVar(133)], found Int at line 1.  Also 1:: [true]; 
  tail([1]) == tail([false])

2. Allow empty blocks, "for(x <- [2]){ }"; "def f[A,B](x: A, y: B): A = x; for(if f(true, #A1)){ }" (TypeCheckerTest1, l. 218) -- done 

3. Add untyped cell reads in TopLevelTest -- done

4. Check Frames in typechecker -- store untypedCell no. -- done

5. Consider the case of "[] == [3]" and "[] = [f]" for f a function.  cf TypeEnv.isEqType, case TypeVar -- done
-- Change isEqType to return Reply[TypeEnv], in the case of TypeVar(tv),
   updating to map tv to EqTypeConstraint.  Handle in TypeChecker.typeCheckBinOp

1. Tidy up typechecking of cell expressions -- common code -- done
-- Tidy up ExpParser. -- done

-- Deal with missing newline at end of file. -- done

1. Remove typing of cells in some places, where the typechecker can deduce the
type.
- Initially allocate type variable to the type. -- done
- Potentially unify that type subsequently. -- done
- At the end of evaluation of the enclosing expression (the call to typeCheck 
  from typeCheckStmt), check that the type has  been decided.
- Augment type environment with list of those cell reads awaiting types. -- done
- Update Execution to handle this construct

2. Improve parser errors, e.g. when types omitted on cells.  Implement ~! -- done
- Add backtrackable field to ParseResult
- Take conjunction in ~, etc.
- Implement in |
- Implement ~!

2. Parse error with
def sumCol(c: Column, r: Row, end: Row): Int = 
  if(r == end) 0 else sumCol(c, r+1, end) + Cell(c,r) -- ok with parentheses.
1. Add cell type matching, e.g. 
 #B3 match{ case x: Int => ...; case st: String => ...; case Blank => ... }
This is a new syntactic category. 
- Define syntax -- done
- Parsing -- done
- Typechecking -- done
- Evaluation -- done
