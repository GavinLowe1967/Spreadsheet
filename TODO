https://retractionwatch.com/2013/04/18/influential-reinhart-rogoff-economics-paper-suffers-database-error/

Current
=======

1. Add double-write error, giving all places where written.

(a) Set CellSource when value entered, or CSV read in.  Stop
  Environment.getCell from adding source. -- done

(b) When writing to cell, add source; so there are potentially two types of
  sources, the cell the value was read from, and the script code that produced
  that value.  Set combinatiopn in Execution.perform, case Directive. -- done

(c) show in selection -- done

(d) Add double-write error

(e) Can a write overwrite user data?  

2. Add more patterns for cell match expressions, e.g. "_" or "_: Int" as
   wildcard?  -- DONE
a) Syntax: done
b) Parsing: done
c) Typechecking: done
d) Evaluation: done


Priorities
==========

* Tidy up parsing files

* Overloading.

* List comprehensions.

* Allow assertions, error.

* "println" statements.

* Add "if" directives.

* Haskell standard prelude.

* Improve syntax for function declarations and applications -- currying.

Low Priority
============

* Improve treatment of Strings:
- Allow non-quoted strings in CSV
- Think about escaped characters in non-quoted string cells.

* Order relations on rows, columns

* Look again at Unification.scala.  Are all branches tested?

* Catch stack overflows.







===================================== DONE


1. Tidy up this file!

- Seems to need newline at end 

- EqTypeConstraint.intersection -- test **

- Parser for strings in script.  

- Improve error messages concerning polymorphic types: "val xs = head(3)" ->
  Expected List[TypeVar(133)], found Int at line 1.  Also 1:: [true]; 
  tail([1]) == tail([false])

2. Allow empty blocks, "for(x <- [2]){ }"; "def f[A,B](x: A, y: B): A = x; for(if f(true, #A1)){ }" (TypeCheckerTest1, l. 218) -- done 

3. Add untyped cell reads in TopLevelTest -- done

4. Check Frames in typechecker -- store untypedCell no. -- done

5. Consider the case of "[] == [3]" and "[] = [f]" for f a function.  cf TypeEnv.isEqType, case TypeVar -- done
-- Change isEqType to return Reply[TypeEnv], in the case of TypeVar(tv),
   updating to map tv to EqTypeConstraint.  Handle in TypeChecker.typeCheckBinOp

1. Tidy up typechecking of cell expressions -- common code -- done
-- Tidy up ExpParser. -- done

-- Deal with missing newline at end of file. -- done

1. Remove typing of cells in some places, where the typechecker can deduce the
type.
- Initially allocate type variable to the type. -- done
- Potentially unify that type subsequently. -- done
- At the end of evaluation of the enclosing expression (the call to typeCheck 
  from typeCheckStmt), check that the type has  been decided.
- Augment type environment with list of those cell reads awaiting types. -- done
- Update Execution to handle this construct

2. Improve parser errors, e.g. when types omitted on cells.  Implement ~! -- done
- Add backtrackable field to ParseResult
- Take conjunction in ~, etc.
- Implement in |
- Implement ~!

2. Parse error with
def sumCol(c: Column, r: Row, end: Row): Int = 
  if(r == end) 0 else sumCol(c, r+1, end) + Cell(c,r) -- ok with parentheses.
1. Add cell type matching, e.g. 
 #B3 match{ case x: Int => ...; case st: String => ...; case Blank => ... }
This is a new syntactic category. 
- Define syntax -- done
- Parsing -- done
- Typechecking -- done
- Evaluation -- done
