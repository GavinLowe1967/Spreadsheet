https://retractionwatch.com/2013/04/18/influential-reinhart-rogoff-economics-paper-suffers-database-error/

Current
=======


* Overloading.

- Use the following rule: an overloaded function may not have a polymorphic
  instance.  This avoids a lot of difficulties, and doesn't seem to lose much
  -- only distasteful overloadings.

?? And allow overloading only via defs -- not vals.  This seems consistent with
  the rule that forward-references to vals are not allowed, and we calculate
  the types of vals in order of declaration: we don't want to add a type for
  an overloaded def/val part way through.

- Require all uses of an overloaded function to either be an application of
  that function, (e.g. "double(3.4)") or explicitly typed (e.g. "map(double:
  Int => Int, List(3))").  [Aside: in the latter cases, if not explicitly
  typed, e.g. map(double, List(3)), Scala picks the instance by a mechanism
  that seems arbitrary.]

Plan:

1. Extend environment to map each name to a list of values.  Arrange for get
to return Option[List[TypeT]].  **temporarily** keep sigs of + and ++, but
store singleton list. -- done

2. Update the NameExp case to treat None as at present, Some(List()) as a
forward-reference failure, Some(List(t)) as present, and Some(ts) as an
overloading failure. -- done

2a. Change block code to map new names to List(), so attempts to access them
before the definition will generate "forward reference" errors. -- done

<testing here unchanged>  -- done

3a. Add version of TypeEnv.++ to take a list of types, and to overwrite
previous types. -- done

3b. At start of new scope (DeclarationTypeChecker.typeCheckDeclList):
a. Check that overloaded functions are not polymorphic (no polymorphic types
for arguments). -- done; 
b. Check that argument types of overloaded functions are
disjoint (easy because of lack of polymorphism).  -- done
c. Map names of functions to the relevant list of types. -- done

<testing here unchanged, but can't deal with application of overloaded function>

4. Add a case FunctionApp(NameExp(fn), args) to typeCheck.  Identify the
  instance that applies.  This should be unique.  Typecheck based on this.

<add tests of typechecker with overloading>

5. Record the instance of the function in the FunctionApp object. 
a. For each overloaded name, store in each FunctionDeclaration object its
index in the corresponding list of types.  -- done
b. Store that index in the FunctionApp object at step 4. -- done

<testing here unchanged>

6. At the point of execution of a FunctionDeclaration, store the corresponding
FunctionValue against a string formed from `name` and the index. -- done

7. At the point of evaluation of a function app, obtain the relevant instance
by using the name stored in the FunctionApp object. -- done

*** 8. Add case TypedExp(NameExp(n), t) to ExpTypeChecker

----- Previous musings

? Add function that, given list of types, finds the instance (if any) that
  matches a given type.

? Add function that, given list of function types, finds the instance (if any)
  that matches a given argument type.

 Note:
  declarations from outer scopes are removed.  This means nameMap needs to
  record the level of scope nesting.  Or store function bindings in a separate
  component -- updated only in DeclarationTypeChecker.checkDisjointNames.

- Add new case in ExpTypeChecker.apply TypedExp(NameExp(n), t) that allows n
  to be overloaded.  Don't allow overloading in the simple NameExp(n) case.

- At point of declaration, check argument types are distinct: this is easy
  given the above rule.  (TypeCheker.typeCheckStmtList.)

- Allow overloading only in the case of FunctionApp(NameExp(fn), args).  In
  more general case, require the function to evaluate to a FunctionType.

- At point of typechecking a function application, identify the instance that
  applies.  This should be unique.  Record the type of the arguments for this
  unique instance in the FunctionApp object.  Consider cases like def
  f(x:Int,y:Int) = ...; def f(x:Float,y:Float) = ...; f(3,#A1).



Priorities
==========




* Allow typing on LHS of val declarations, e.g. "val x: Int = 3", "val x: Int
  = #A3".

* List comprehensions.

* Allow assertions, error.

* "println" statements.

* Add "if" directives.

* Haskell standard prelude.

* Improve syntax for function declarations and applications -- currying.

Low Priority
============

* Improve treatment of Strings:
- Allow non-quoted strings in CSV
- Think about escaped characters in non-quoted string cells.

* Order relations on rows, columns

* Look again at Unification.scala.  Are all branches tested?

* Catch stack overflows.

* In Environment, use null intead of Empty() (to save memory). 


======================================================================

===================================== DONE


** I think at present, the typechecker will pass a val declaration that makes
   a forward reference to a function def, but execution will fail.  e.g.

     val x = f(3); def f(y: Int): Int = y+4

   Type checking succeeds because it is done starting from an environment that
   includes all the claimed types for defs.  Execution fails, because it
   processes the declarations in order, and so the evaluation of x doesn't
   have access to the value of f.  Execution of recursive functions works
   (assuming no forward references) because the body of the function is
   evaluated in an environment that includes both functions. 

   Scala effectively initialises vals to default values of the type (null for
   functions), evaluates declarations in order, but allows forward reference
   to defs based upon the possibly default values.  I don't like that.

Rule 1: no forward references to vals

Rule 2: no forward calls to defs from within val declarations.  This includes
indirect calls, e.g.

  def f(x: Int): Int = g(x); val y = f(3); def g(x: Int): Int = x+4

Algorithm:

a. Identify references to local names (i.e. names declared in this block) used
  in each declaration (both references to vals and defs, separately)

b. Find fixed points of function names used in functions, i.e. including via
  indirect calls.

c. Iterate through declarations, and check no forward refs to vals (using (a)),
  and no forward calls to functions from vals (using (b)).

ALTERNATIVE: Evaluate defs before anything else in the block.  This is roughly
the same as Scala, but doesn't allow a val or cell write to depend upon a
later val.  Also, purge new names at the start of the block.  -- done
  

1. Add double-write error, giving all places where written.

(a) Set CellSource when value entered, or CSV read in.  Stop
  Environment.getCell from adding source. -- done

(b) When writing to cell, add source; so there are potentially two types of
  sources, the cell the value was read from, and the script code that produced
  that value.  Set combinatiopn in Execution.perform, case Directive. -- done

(c) show in selection -- done

(d) Add double-write error -- done, needs improving

(e) Can a write overwrite user data?  -- error detected

(f) Can a user input overwrite written data? -- yes
** In these cases, keep the user data, store an error elsewhere. 

(g) Change MultipleWriteError to store list of Values.

(h) Change user feedback, e.g. "Value 5 from cell write at line 53: #D3 = 5",
"User data 5".
-- Mostly done.  Check results again.  Tidy up Execution.writeCell.  Consider 
   the case where the cell already holds a MultipleWriteError. -- done

(i)  Colour all errors red. -- done


1. Split cells into user cells and calculated cells.  Needs change in Model.cells.  

* Changes in Environment: userCells and calculatedCells initialised with Empty()

* Change cells in Model to getCell.

* In TopLevelTest, re-add tests for errors

* Use null to represent empty cells, and adapt getCell

*** For loops with repeated names. - test; add to TopLevelTest -- done

*** Explicit type for function. - test -- done 

*** Should typechecking of for statement start new scope for each generator?
    I don't think so, because it doesn't backtrack into the earlier scope.

2. Add more patterns for cell match expressions, e.g. "_" or "_: Int" as
   wildcard?  -- DONE
a) Syntax: done
b) Parsing: done
c) Typechecking: done
d) Evaluation: done

*** does parser work on, e.g. truely + 3?  It does now.

* Tidy up parsing files.  
  - Split expressions and declarations into separate file -- done
  - Split parsers for types into separate class. -- done

* Allow typed expressions, e.g. "[]: List[Int]".  ":" should bind more tightly
  than infix operators.  Have new syntactic term TypedExp(e: Exp, t: TypeT).
  - New syntactic term -- done
  - Parsing, excluding typed cell reads -- done
  - Type checking -- done
  - Execution. -- done

1. Tidy up this file!

- Seems to need newline at end 

- EqTypeConstraint.intersection -- test **

- Parser for strings in script.  

- Improve error messages concerning polymorphic types: "val xs = head(3)" ->
  Expected List[TypeVar(133)], found Int at line 1.  Also 1:: [true]; 
  tail([1]) == tail([false])

2. Allow empty blocks, "for(x <- [2]){ }"; "def f[A,B](x: A, y: B): A = x; for(if f(true, #A1)){ }" (TypeCheckerTest1, l. 218) -- done 

3. Add untyped cell reads in TopLevelTest -- done

4. Check Frames in typechecker -- store untypedCell no. -- done

5. Consider the case of "[] == [3]" and "[] = [f]" for f a function.  cf TypeEnv.isEqType, case TypeVar -- done
-- Change isEqType to return Reply[TypeEnv], in the case of TypeVar(tv),
   updating to map tv to EqTypeConstraint.  Handle in TypeChecker.typeCheckBinOp

1. Tidy up typechecking of cell expressions -- common code -- done
-- Tidy up ExpParser. -- done

-- Deal with missing newline at end of file. -- done

1. Remove typing of cells in some places, where the typechecker can deduce the
type.
- Initially allocate type variable to the type. -- done
- Potentially unify that type subsequently. -- done
- At the end of evaluation of the enclosing expression (the call to typeCheck 
  from typeCheckStmt), check that the type has  been decided.
- Augment type environment with list of those cell reads awaiting types. -- done
- Update Execution to handle this construct

2. Improve parser errors, e.g. when types omitted on cells.  Implement ~! -- done
- Add backtrackable field to ParseResult
- Take conjunction in ~, etc.
- Implement in |
- Implement ~!

2. Parse error with
def sumCol(c: Column, r: Row, end: Row): Int = 
  if(r == end) 0 else sumCol(c, r+1, end) + Cell(c,r) -- ok with parentheses.
1. Add cell type matching, e.g. 
 #B3 match{ case x: Int => ...; case st: String => ...; case Blank => ... }
This is a new syntactic category. 
- Define syntax -- done
- Parsing -- done
- Typechecking -- done
- Evaluation -- done
